#!/usr/bin/env node
'use strict';

const {spawn} = require('child_process');
const path = require('path');
const helper = require('../../helpers/helper');
const logger = require('../../helpers/logger').winstonLogger;
const CLIUtils = require('../v2/cliUtils');
const {getLoadConfigPath} = require('./loadUtils');

async function executeLoadTest(yargs) {
  try {
    const rawArgs = process.argv.slice(2);
    const loadArgs = rawArgs.slice(1);

    logger.debug('Executing load test with arguments:', loadArgs);
    const isHelpCommand = loadArgs.includes('--help') || loadArgs.includes('-h');
    let config = {};

    try {
      logger.debug('Loading configuration...');

      const configPath = getLoadConfigPath(yargs.argv);
      logger.debug('Configuration path:', configPath);

      if (configPath) {
        config = helper.readConfig(configPath);
      } else {
        logger.debug('No configuration file found, using environment variables if available.');
        config = {
          username: process.env.BROWSERSTACK_USERNAME || process.env.BROWSERSTACK_USER,
          accessKey: process.env.BROWSERSTACK_ACCESS_KEY || process.env.BROWSERSTACK_ACCESSKEY
        };
      }

      logger.debug('Configuration loaded successfully');
    } catch (error) {
      logger.error('Error loading configuration:', error.message);
      process.exit(1);
    }

    // Get the CLI directory
    const cliDir = CLIUtils.getCliDir();
    if (!cliDir) {
      logger.error('Failed to determine CLI directory');
      process.exit(1);
    }

    // Check if CLI binary exists
    let binaryPath = CLIUtils.getExistingCliPath(cliDir);

    // If CLI doesn't exist or needs to be updated, download it
    // Pass config to CLI download/update process
    if (!binaryPath) {
      logger.debug('CLI binary not found, downloading latest version');
      binaryPath = await CLIUtils.checkAndUpdateCli('', cliDir, config);
    } else {
      logger.debug('CLI binary found, Checking for CLI updates');
      binaryPath = await CLIUtils.checkAndUpdateCli(binaryPath, cliDir, config);
    }

    if (!binaryPath) {
      logger.error('Failed to download or locate CLI binary');
      process.exit(1);
    }

    logger.debug(`Spawning: ${binaryPath} load ${loadArgs.join(' ')}`);

    // Pass all arguments directly to the CLI binary
    const childProc = spawn(binaryPath, ['load', ...loadArgs], {
      stdio: 'inherit'
    });

    let isExiting = false;

    // Promise that resolves when the child process exits
    const childProcessPromise = new Promise((resolve) => {
      childProc.on('close', (code) => {
        logger.debug(`${binaryPath} exited with code ${code}`);
        resolve(code);
      });
    });

    // Handle signals like SIGINT (Ctrl+C), SIGTERM, etc.
    ['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGHUP'].forEach(signal => {
      process.on(signal, () => {
        if (isExiting) {
          return;
        }
        isExiting = true;

        logger.debug(`Received ${signal}, forwarding to child process...`);

        // Forward the signal to the child process
        if (childProc && !childProc.killed) {
          childProc.kill(signal);
          logger.debug('Waiting for child process to exit...');
        }
      });
    });

    // Wait for the child process to complete
    const exitCode = await childProcessPromise;

    // Exit with the same code as the child process
    process.exit(exitCode);

  } catch (error) {
    logger.error(`Failed initiating load test: ${error.message}`);
    process.exit(1);
  }
}

module.exports = executeLoadTest;
